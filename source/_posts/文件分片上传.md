---
title: 文件分片上传
date: 2021-11-24 13:56:00
tags: upload file chunk 
banner_img: /images/文件分片上传/background.jpg
index_img: /images/文件分片上传/background.jpg
categories: 
  - 文件
  - 上传
  - 前端    
---

## 前端文件分片上传流程  

## 介绍  
作为一个前端，平常工作中肯定离不开文件上传的业务需求，可能大部分情况都是对图片，附件等一些小文件进行上传，但是当需要上传大文件的时候，使用普通上传方式时，可能就会看到接口返回`413`，这里就需要提到本文所要说的文件分片上传。    

## 正文  
### 二进制数据类型  
前端对二进制数据的存储格式有很多种。  
- `input`输入框上传文件时用到的[File](https://developer.mozilla.org/zh-CN/docs/Web/API/File)类型。 
- 视频网站上能看到的`blob`链接资源  
- `es6`中出现的`ArrayBuffer`，并且是文件分片上传，断点续传的基础。   
- 还有一个就是`base64`  

### 不同类型的相互转换  
很多数据类型的转换都需要依靠于[FileReader](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader)  
1. `ArrayBuffer to Blob`  

```js 
  const blob = new Blob([new ArrayBuffer(1024)])  
  const fileReader = new FileReader()

  fileReader.onload = function() {
    console.log(fileReader.result)
  }

  fileReader.readAsArrayBuffer(blob)

```

2. `Blob to Base64`  

``` js
  const blob = new Blob([new ArrayBuffer(1024)])  
  const fileReader = new FileReader()

  fileReader.onload = function() {
    console.log(fileReader.result)
  }

  fileReader.readAsDataURL(blob)
```

以上是两个简单的数据类型转换的例子   

### 需要使用到的npm package  
- `spark-md5 ` 
[spark-md5](https://www.npmjs.com/package/spark-md5)可以将对应的数据进行`md5`加密，这样在下一次对同一个文件进行上传时，可以直接跳过整个上传流传，实现秒传的效果。  

### 具体流程  
- `input`接收文件`template.mp4`  
- 获取文件的基础信息  
  - 文件的`mime`，当前的类型是`video/mp4`  
  - 文件的大小`file.size`，假设本次文件的大小为`1G`  
  - 设置本次上传分片的大小为`5M`  
  - 计算本次上传的分片数量为`1G / 5M = 205`，所以本次需要上传205次  
- 对文件进行分片  
  - 使用`spark-md5`进行分片  
``` js 
  import { ArrayBuffer } from 'spark-md5'
  
  const SparkMd5 = new ArrayBuffer()

  // 保存分片用于在后面上传时用  
  const cacheChunks = []
  // 当前分片的索引
  const index = 0
  // 分片的大小
  const chunkSize = 1024 * 1024 * 5 
  // file 只需要简单调用 file.slice 就可以
  const currentChunk = file.slice(index * chunkSize, (index + 1) * chunkSize)  

  cacheChunks.push(currentChunk)

  // 添加分片  
  SparkMd5.append(currentChunk)

  // 所有分片添加完成时  
  const md5 = SparkMd5.end()

  // 完成解析后销毁对应实例  
  SparkMd5.destroy()

```

- 文件存在性检查  
将文件的一些信息传递给后台，服务端检查文件是否存在。  
如果存在，则跳过之后的上传过程。
如果不存在，则继续后面的上传流程。  

- 文件分片上传  
按照索引顺序对文件分片进行上传  
```js
  import axios from 'axios'

  const formData = new FormData()
  // 需要上传的文件分片
  formData.append("file", chunk)
  // 当前分片的索引  
  formData.append("index", index)
  // 文件md5 
  formData.append("md5", md5)

  axios.post("/path/to/upload", formData)

```
后端通过返回下一分片的索引或者是下一分片的范围来指定前端接下来需要上传的分片  
在上一步骤中也可以返回和这一步骤相同的内容。  

- 文件上传完成通知  
这一步骤为可选步骤，通过前端通知后端完成了所有文件分片的上传。  
一般不需要前端主动向后端通知。  


### 后端实现  
这里简单使用`node`讲解一下后端接收文件的基本逻辑   
使用`koa`做基础服务  
使用`koa-body`接收前端的文件内容  
使用`koa-router`做对应的restful设计  

1. 文件存在性检查
```js

  let fileCache = {}

  router
  .get("/", async (ctx) => {
    const { md5, chunkSize, filename, size, length } = ctx.query 
    if(fileCache[md5] && fileCache[md5].chunks.length === length) {
      ctx.body = {
        success: true,
        res: {
          data: true 
        }
      }
      return
    }else if(fileCache[md5]) {
      const index = findLastUnUploadChunkIndex()
      ctx.body = {
        success: true,
        res: {
          data: index
        }
      }
    }else {
      fileCache[md5] = {
        chunks: [],
        size,
        length,
        chunkSize,
        md5
      }
      ctx.body = {
        success: true,
        res: {
          data: 0
        }
      }
    }
  })
```

2. 文件上传  
```js
  router.post("/", async (ctx) => {
    const files = ctx.request.files.file 
    const { md5, index } = ctx.request.body 
    fileCache[md5].chunks.push(index) 
    // 使用fs保存对应的分片至指定文件夹
    // 分片名称可以使用md5-index的形式
  })
```

3. 文件合并  
```js 
  const fs = require("fs")
  const fsPromise = fs.promises  

  // 合并分片
  async function mergeChunk() {

    const realFilePath = "/path/to/real/file"

    // 获取对应的文件分片文件名称  
    const chunkList = await fsPromise.readdir("/path/to/chunk")  

    // 对文件进行排序  
    chunkList.sort((suffixA, suffixB) => Number(suffixA.split('-')[1]) - Number(suffixB.split('-')[1]))
    
    //文件合并
    const mergeTasks = async () => {
      for(let i = 0; i < chunkList.length; i ++) {
        const chunk = chunkList[i]
        await fs.readFile(chunk)
        .then(data => fs.appendFile(realFilePath, data))
        .then(_ => fs.unlink(chunk))
      }
    }

    return fs.writeFile(realFilePath, '')
    .then(mergeTasks)
    .catch(err => {})
  }

```

## 结束  
以上就是整个文件分片上传的流程，当中的具体细节可以查看本人完成的对应的[上传工具类库](https://food-billboard.github.io/chunk-file-load/#/)，还有基于该类库封装的`React`[上传组件](https://food-billboard.github.io/chunk-file-load-component/#/)  

