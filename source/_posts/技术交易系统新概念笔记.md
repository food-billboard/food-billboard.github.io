---
title: 技术交易系统新概念笔记
date: 2022-11-28 09:13:00
tags: trade finance 
banner_img: /images/技术交易系统新概念笔记/background.jpeg
index_img: /images/技术交易系统新概念笔记/background.jpeg
categories: 
  - 交易
---

# 技术交易系统新概念笔记  

## 介绍  
  本文是本人在阅读了《技术交易系统新概念》所作的笔记。  

## 开始  

### 目录 

  记录一下目录：  
> 
  第一章 基本概念  
  第二章 抛物式时间/价格交易系统  
  第三章 波动交易系统  
  第四章 动向指标  
  第五章 动量概念-趋势平衡点交易系统  
  第六章 相对强弱指数  
  第七章 趋势-回调交易系统  
  第八章 摆动指标-短线交易系统  
  第九章 期货品种选择指标CSI  
  第十章 资金管理  

### 基本概念  

这里用到的一些概念会贯穿所有章节使用，需要提前记好。  

#### LOP | HIP  

- LOP  
其相邻的两根K线的最低价都高于其最低价  
- HIP  
其相邻的两根K先的最高价均低于其最高价  

<img src="/images/技术交易系统新概念笔记/基本概念-LOP-HIP.png" />

#### SIP(HI SIP | LO SIP)  

简单来说应该就是最高和最低价格的意思吧。  

<img src="/images/技术交易系统新概念笔记/基本概念-SIP.png" />

#### SIC   

表示交易中最有利的**收盘价**。  
多头表示最高价。  
空头表示最低价。  

#### SAR  

停止反转点，表示停止现有头寸，反方向操作。  

#### TR  

  真实价格范围   
  去下列值中的最大值  
  1. 最高价与最低价的差  
  2. 最高价与昨日收盘价的差  
  3. 最低价与昨日收盘价的差  

#### MOCK模板  
  这里简单记录一下`javascript`实现的一个代码任务运行模板（其实就是怕自己忘记😁 ）  
```js

  const DATA_SOURCE = []

  // 获取指定时间间隔的历史数据
  // mock 
  function getHistoryData(start, end) {
    const date = new Date()
    return [{
      high,
      open,
      low,
      close,
      date: `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`
    }]
  }

  // 获取真实价格范围
  function getTR(currentData, yestodayData) {
    const abs = Math.abs
    return Math.max(abs(currentData.high - currentData.low), abs(currentData.high - yestodayData.close), abs(currentData.low - yestodayData.close))
  }

  // 定时任务执行
  function dailyFunction() {

  }

```

### 抛物式时间/价格交易系统  

  个人认为：  
  非常偏向数学方法的趋势跟踪系统。  
  只要记住他的计算功能，就非常容易完成整个系统。  
  马上就可以尝试使用代码完成系统。  

  记住几个关键的参数：  
  - AF  
    加速因子[0.02-0.2]  
    当日创下价格新高则`AF+0.02`(多头为新高，空头为新低)    
  - SAR  
    停止反转点  
  - SIP  
    价格极值  
  - EP  
    此次交易开始的最极值（多头为最高，空头为最低）。       

  `明日SAR = 今日SAR + AF(今日最高价 - 今日SAR)`  

#### 规则  
  - 入市时机  
    价格突破`SAR`  
  - 建仓第一天  
    SAR = 前一次交易SIP  
  - 第一天之后  
    多头：`明日SAR = 今日SAR + AF(最高价 - 今日SAR)`  
    空头：`明日SAR = 今日SAR - AF(最低价 - 今日SAR)`  
  - SAR不允许出现在前一日或今日价格区域  
    多头：明日SAR不能大于昨日或今日最低价，大于则`明日SAR = min(今日最低价，明日最低价)`  
    空头：明日SAR不能小于昨日或今日最高价，小于则`明日SAR = max(今日最高价，明日最高价)`  

```typescript
  let DATASOURCE: {
    state: 1 | -1 // 1 多头 -1 空头
    dailyData: { // 每日的交易数据
      date: string // 日期
      open: number // 开盘价
      high: number // 最高价
      low: number // 最低价
      close: number // 收盘价
      SAR: number 
      EP: number // 此次交易的极值
      EP_SAR: number // EP+-SAR 当前最高价和今日SAR 的差值
      AF: number // 加速因子
      AF_DIFF: number // EP_SAR * AF  
    }[]
  } = []

  // 模拟交易
  // 用于下面的首次入市前的准备工作
  let MOCK_DATASOURCE = []

  // 获取指定时间间隔的历史数据
  function getHistoryData(start, end) {
    const date = new Date()
    return [{
      high,
      open,
      low,
      close,
      date: `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`
    }]
  }

  // 之前从未做过交易
  // 需要先找出前几周前的 最高|最低 点  
  // 基于是上升还是下跌趋势  
  // 当前设置为3周前  
  function getBeforeWeekPeak() {

    // 获取3周的时间间隔
    let startDate
    let endDate 

    // 第一天启用程序
    if(!MOCK_DATASOURCE.length) {
      const historyData = getHistoryData()
      // TODO 
      // 判断前几周的趋势
      
      let peakData 
      let peakIndex 
      // 如果是上升
      if(true) {
        // 找出前三周的最高点
        historyData.forEach((history, index) => {
          if(!peakData || history.high > peakData.high) {
            peakData = history 
            peakIndex = index 
          }
        })
        // 找出最高点后4天的最低点
        // 作为入市点
        const enterDate = historyData.slice(peakIndex, peakIndex + 4)
        const SAR = peakData.high
        const EP = enterDate.low
        const EP_SAR = Math.abs(SAR - EP)
        MOCK_DATASOURCE.push({
          state: -1,
          dailyData: [
            date: enterDate.date,
            open: enterDate.open,
            high: enterDate.high,
            low: enterDate.low,
            close: enterDate.close,
            SAR, 
            EP,
            EP_SAR,
            AF: 0.02,
            AF_DIFF: EP_SAR * 0.02
          ]
        })
      }
      // 下跌
      else {
        // 找出前三周的最低点
        historyData.forEach((history, index) => {
          if(!peakData || history.low < peakData.low) {
            peakData = history 
            peakIndex = index 
          }
        })
        // 找出最低点后4天的最高点
        // 作为入市点
        const enterDate = historyData.slice(peakIndex, peakIndex + 4)

        const SAR = peakData.low
        const EP = enterDate.high
        const EP_SAR = Math.abs(SAR - EP)
        MOCK_DATASOURCE.push({
          state: 1,
          dailyData: [
            date: enterDate.date,
            open: enterDate.open,
            high: enterDate.high,
            low: enterDate.low,
            close: enterDate.close,
            SAR, 
            EP,
            EP_SAR,
            AF: 0.02,
            AF_DIFF: EP_SAR * 0.02
          ]
        })
      }
    }

    // TODO 
    // 持续进行模拟记录数据
    // 但是这里有一点还没有弄清楚
    // 先暂时卡着吧

  }

  // 每日需要执行的函数
  function dailyFunction(options={
    mock: false,
    date: null 
  }) {

    const { mock, date } = options 
    const _DATASOURCE = mock ? MOCK_DATASOURCE : DATASOURCE

    // 初始化今日数据
    const todayData = getHistoryData(date, date)
    const newDailyData = {
      ...todayData,
    }

    // 之前未做过交易
    // 可以选择以下方法
    // 也可以选择使用后面说到的第四章的方法（动向指数）
    if(!_DATASOURCE.length) {
      return getBeforeWeekPeak()
    }

    // 是否今日开启交易
    const lastTradeNote = _DATASOURCE[_DATASOURCE.length - 2]
    const currentTradeNote = _DATASOURCE[_DATASOURCE.length - 1]
    const { dailyData, state } = currentTradeNote

    // 第一天
    if(!dailyData.length) {
      // 之前存在交易
      if(!!lastTradeNote && Array.isArray(lastTradeNote.dailyData) && lastTradeNote.dailyData.length) {
        const { dailyData, state } = lastTradeNote
        // 多头则获取前一次交易的最低价
        // 空头则获取前一次交易的最高价
        // 这里只需要取前一次交易的最后一天的极值EP即可
        newDailyData.SAR = dailyData[dailyData.length - 1].EP
        newDailyData.EP = state === 1 ? newDailyData.high : newDailyData.low
      }
    }
    // 非第一天
    else {
      // 前一天的数据
      const yestodayData = dailyData[dailyData.length - 1]
      const beforeYestodayData = dailyData[dailyData.length - 2] || {
        low: 999999,
        high: -1
      }
      
      if(state === 1) {
        newDailyData.SAR = yestodayData.SAR + yestodayData.AF_DIFF
        // 多头 SAR 不得大于前一日或今日最低价，大于则选择当日或昨日最低价
        const lessThenPrize = Math.min(yestodayData.low, beforeYestodayData.low)
        newDailyData.SAR = newDailyData.SAR === Math.min(lessThenPrize, newDailyData.SAR) ? newDailyData.SAR : lessThenPrize

        newDailyData.EP = Math.max(yestodayData.EP, newDailyData.high)
      }else {
        newDailyData.SAR = yestodayData.SAR - yestodayData.AF_DIFF
        // 空头 SAR 不得小于前一日或今日最高价，小于则选择党日或昨日最高价
        const greatThenPrize = Math.max(yestodayData.high, beforeYestodayData.high)
        newDailyData.SAR = newDailyData.SAR === Math.max(lessThenPrize, newDailyData.SAR) ? newDailyData.SAR : lessThenPrize

        newDailyData.EP = Math.min(yestodayData.EP, newDailyData.low)
      }
    }

    // 获取 EP 和 SAR 的差值
    newDailyData.EP_SAR = Math.abs(newDailyData.SAR - newDailyData.EP)
    newDailyData.AF = newDailyData.AF || 0.02 
    // 创新高或新低则增加AF值
    if(state === 1) {
      newDailyData.AF += newDailyData.high > newDailyData.EP ? 0.02 : 0
    }else {
      newDailyData.AF += newDailyData.low < newDailyData.EP ? 0.02 : 0
    }
    newDailyData.AF = Math.min(0.2, newDailyData.AF)
    newDailyData.AF_DIFF = newDailyData.AF * newDailyData.EP_SAR

    // 多头发生价格突破
    const isMultiBreak = state === 1 && newDailyData.low < newDailyData.SAR
    // 空头发生价格突破
    const isEmptyBreak = state === -1 && newDailyData.high > newDailyData.SAR

    if(isMultiBreak || isEmptyBreak) {
      newDailyData.AF = 0.02 
      newDailyData.SAR = newDailyData.EP 
      newDailyData.EP = state === 1 ? newDailyData.low : newDailyData.high 
      newDailyData.EP_SAR = Math.abs(newDailyData.SAR - newDailyData.EP)
      newDailyData.AF_DIFF = newDailyData.EP_SAR * newDailyData.AF

      console.log((state === 1 ? '多头' : '空头') + '价格发生突破')

      _DATASOURCE.push({
        state: -1,
        dailyData: [
          {
            ...newDailyData,
          }
        ]
      })
    }
    // 记录今日数据
    else {
      console.log('今日价格数据:' + JSON.stringify(newDailyData))
      _DATASOURCE[_DATASOURCE.length - 1].dailyData.push(newDailyData)
    }

  }

  // 数据清空
  function clearData() {
    DATASOURCE = {
      state: 1,
      dailyData: []
    }
    MOCK_DATASOURCE = {
      state: 1,
      dailyData: []
    }
  }


```

### 波动交易系统  

也是一个趋势跟踪的系统。  
根据市场的波动性来作出相应的操作。  

- `ATR`计算  
<img src="/images/技术交易系统新概念笔记/波动交易系统-ATR.jpg" />  

`ATR_t`是当日平均真实价格范围，`ATR_p`是前一日的平均真实价格范围。  
`TR`是当日真实价格范围。  

上述计算是根据七个交易日为标的做的计算。  
`ATR_p`即将加上今日以及前6个交易日的真实价格范围相加，并除7得出的，之后每一日的计算只要简单得将**前一日的平均真实价格范围**带入上述公式即可。  

- ARC 
  `ARC = ATR * C`  
  C是一个[2.8, 3.1]之间的常数（一般为3）。  

- 系统交易规则  

  计算出七天的`ARC`，找出七天最高收盘价`SIC`，`SAR = SIC - ARC`  
  若第二日的收盘价低于`SAR`，平仓建立空头。  
  

#### 真实价格范围  

  取以下三种的最大值。  
  1. 当日最高价到当日最低价的范围。  
  2. 昨日收盘价到当日最高价的范围。  
  3. 昨日收盘价到当日最低价的范围。  

#### 代码实现  
```typescript 

  // 常数C 
  const C = 3 // [2.8, 3]

  const DATA_SOURCE: {
    state: 1 | -1 // 当前是空头(-1)还是多头(1)
    TR: number // 当日的真实价格范围
    ATR: number // 当日的平均真实价格范围
    ARC: number // ATR * C
    SAR: number // 停止反转点  
    SIC: number // 最低收盘价
    high: number 
    close: number 
    low: number 
    open: number 
    date: string 
  } = []

  // 获取指定时间间隔的历史数据
  function getHistoryData(start, end) {
    const date = new Date()
    return [{
      high,
      open,
      low,
      close,
      date: `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`
    }]
  }

  // 获取真实价格范围
  function getTR(currentData, yestodayData) {
    const abs = Math.abs
    return Math.max(abs(currentData.high - currentData.low), abs(currentData.high - yestodayData.close), abs(currentData.low - yestodayData.close))
  }

  // 每日定时执行方法
  function dailyFunction() {

    const currentDateData = getHistoryData()

    // 之前未做过任何交易
    if(DATA_SOURCE.length < 7) {
      // 简单从空头位置开始准备进入市场
      if(DATA_SOURCE.length < 6) {
        DATA_SOURCE.push({
          ...currentDateData,
          TR: getTR()
        })
      }else {
        const TR = getTR()
        const ATR = DATA_SOURCE.map(item => item.TR).reduce((acc, cur) => acc + cur, 0) / 7
        DATA_SOURCE.push({
          ...currentDateData,
          TR,
          ATR,
          ARC: ATR * C
        })
      }
    }

    const [lastDayData] = DATA_SOURCE.slice(-1)

    const todayTR = getTR(currentDateData, lastDayData)
    const todayATR = (6 * lastDayData.ATR + todayTR) / 7
    const ARC = todayATR * C
    let SIC 
    let SAR 
    let state 
    // 空头
    if(lastDayData.state == -1) {
      SIC = Math.min(lastDayData.SIC, currentDateData.close)
      SAR = lastDayData.SIC + lastDayData.ARC
      // 收盘价上穿SAR 变为多头
      state = currentDateData.close > SAR ? 1 : -1
      // 变为多头更改SIC为当日收盘价
      if(state === 1) {
        SIC = currentDateData.close
      }
    }
    // 多头
    else {
      SIC = Math.max(lastDayData.SIC, currentDateData.close)
      SAR = lastDayData.SIC - lastDayData.ARC
      // 收盘价下穿SAR 变为空头
      state = currentDateData.close < SAR ? -1 : 1
      // 变为空头更改SIC为当日收盘价
      if(state === 1) {
        SIC = currentDateData.close
      }
    }

    const newData = {
      ...currentDateData,
      TR: todayTR,
      ATR: todayATR,
      ARC,
      SIC,
      SAR,
      state
    }

    // 上面state改变则触发交易操作
    DATA_SOURCE.push(newData)

  }

```

### 动向指标  

根据一个`0-100`的指标来跟踪产品趋势。  

#### 几个指标概念  

##### +DM和-DM  
今日的价格范围与昨日价格返回的差值  
比如：昨天的价格范围是`[100 200]`，今日的价格范围是`[150, 300]`，则使用`+DM`表示为`300 - 200 = 100`  
<img src="/images/技术交易系统新概念笔记/动向指标-DM.jpg" />

当今日与昨日是**包含**关系时，DM为`0`。  
`+DM`和`-DM`始终是**正数**。  

> 计算规则  
党日价格范围超出昨日价格范围中的较大部分。  

##### +DI和-DI  
方向指数，相对于真实价格范围，变动的百分比。  
<img src="/images/技术交易系统新概念笔记/动向指标-DI.jpg" />  

价格**上涨**用`+DI`，**下跌**用`-DI`。  

<img src="/images/技术交易系统新概念笔记/动向指标-DI14.png" />  

> 求出`14`天的平均值来作为指标，
计算出14天的值以后便可以用简便方法进行计算。  

<img src="/images/技术交易系统新概念笔记/动向指标-DI14-next.jpg" />  

##### DX  
动向指标  
`DX = DIDiff / DISum`（参数详见下表）  
`DX`值越大，运动越**强**；`DX`值月销，运动越**弱**。  
无论价格向上或向下运动，不会影响数值，即向上或向下运动幅度大，那么他的值都很**大**。  

##### ADX  
 14天`DX`的平均值  

##### ADXR  
  方向运动的坐标系上用于量度期货、货币、股票等等的价格变化的一个指标  
  `ADXR = (当日ADX + 14天前的ADX14) / 2`

##### CSI & K  

  - CSI  
    根据相关关联参数计算而得来的产品选择指标  
  - K  
    与`CIS`相关的常量系数  

#### 数据记录  
|  date   | open  |  high   | low  |  close   | TR  |  DMHigh   | DMLow  |  TR14   |  DI14High   | DI14Low  | DIDiff  | DISum  | DX  | ADX  |
|  -----  | -----  |  -----  | -----  |  -----  | -----  |  -----  | -----  |  -----  | -----  | -----  | -----  | -----  | -----  | -----  |
| 日期  | 开盘价 | 最高价  | 最低价 | 收盘价  | 真实价格范围 | +DM  | -DM | TR14 | +DI14  | -DI14 | +DI14 - (-DI14) | +DI14 + (-DI14) | DIDiff / DISum | 14天DX的平均值 |

#### js实现  
```js
  /*
    {
      // 日期
      date: '2022-02-25',
      // 开盘价
      open: 100,
      // 最高价
      high: 100,
      // 最低价
      low: 100,
      // 收盘价
      close: 100,
      // TR  
      TR: 10,
      // +DM 
      DMHigh: 10, 
      // -DM  
      DMLow: 0,
      // TR14  
      TR14: 14,
      // DMHigh14
      DMHigh14: 10,
      // DMLow14
      DMLow14: 10,
      // +DI14 
      DI14High: 10,
      // -DI14
      DI14Low: 10,
      // +DI14和-DI14的差值  
      DIDiff: 10,
      // +DI14和-DI14的和
      DISum: 10,
      // 上面两个值的比值 动向指标
      DX: 10,
      // 14日DX的平均值
      ADX: 30,
      // 平均动向指标比率
      ADXR: 30,
      // 平均14天真实价格范围
      ATR14: 20,
      // 期货品种选择指标
      CSI: 20,
      // 手续费
      charge: 20 
    }
  */
  const DATA_SOURCE = []
  // 当前的交易信息
  const TRADE_INFO = {
    // -1 初始化 0 空头 1 多头
    status: -1,
    // DI14和-DI14交叉时的极端价位，用于消除价格波动噪声  
    limit: -1,
  }

  // 时间跨度 14 天
  const RANGE_DAY_COUNT = 14 

  // 获取指定时间间隔的历史数据
  // mock 
  function getHistoryData(start, end) {
    const date = new Date()
    return [{
      high,
      open,
      low,
      close,
      date: `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`,
      charge,
    }]
  }

  // 获取DM值 
  function getDMData(currentData, yestodayData) {
    const {  
      high: currHigh,
      low: currLow
    } = currentData 
    const {  
      high,
      low
    } = yestodayData 
    let DMHigh = 0 
    let DMLow = 0 

    const condition1 = currHigh - high 

    const condition2 = low - currLow 

    // 如果是包含关系就都为0 
    if(condition1 > 0 || condition2 > 0) {
      // 向上运动更多
      if(condition1 > condition2) {
        DMHigh = condition1
      }
      // 向下运动更多
      else {
        DMLow = condition2
      }
    }

    return {
      DMHigh,
      DMLow
    }
  }

  // 获取真实价格范围
  function getTR(currentData, yestodayData) {
    const abs = Math.abs
    return Math.max(abs(currentData.high - currentData.low), abs(currentData.high - yestodayData.close), abs(currentData.low - yestodayData.close))
  }

  // 定时任务执行
  function dailyFunction() {

    const currentData = getHistoryData() 
    const {
      high,
      open,
      low,
      close,
      date,
      charge
    } = currentData 
    const newData = {
      date,
      high,
      open,
      close,
      low,
      charge
    } 

    // 不是第一天，如果是第一天只需要简单记录数据就可以了
    if(!DATA_SOURCE.length) {
      const yestoday = DATA_SOURCE[DATA_SOURCE.length - 1]

      // DM
      const { DMHigh, DMLow } = getDMData(newData, yestoday)
      newData.DMHigh = DMHigh
      newData.DMLow = DMLow

      // TR  
      const tr = getTR(newData, yestoday)
      newData.TR = tr 

      // 大于最短时间周期（14天），满足所有数据的计算条件
      if(DATA_SOURCE.length >= (RANGE_DAY_COUNT - 1)) {
        
        // 如果是刚好满足条件，需要做累计计算
        if(DATA_SOURCE.length == (RANGE_DAY_COUNT - 1)) {
          const previousData = DATA_SOURCE.slice(DATA_SOURCE.length - RANGE_DAY_COUNT - 1)

          // tr14 
          newData.TR14 = tr + previousData.reduce((acc, cur) => {
            acc += cur.TR
            return acc 
          }, 0)

          // dmhigh14 
          newData.DMHigh14 = DMHigh + previousData.reduce((acc, cur) => {
            acc += (cur.DMHigh || 0)
            return acc 
          }, 0)
          // dmlow14
          newData.DMLow14 = DMLow + previousData.reduce((acc, cur) => {
            acc += (cur.DMLow || 0)
            return acc 
          }, 0)

        }
        // 超过条件只要简单使用昨日数据进行计算即可
        else {
          const { TR14, DMHigh14, DMLow14 } = yestoday

          // tr14
          newData.TR14 = TR14 - TR14 / RANGE_DAY_COUNT + tr 
          // dmhigh14 
          newData.DMHigh14 = DMHigh14 - DMHigh14 / RANGE_DAY_COUNT + DMHigh 
          // dmlow14 
          newData.DMLow14 = DMLow14 - DMLow14 / RANGE_DAY_COUNT + DMLow 

        }

        // ATR14
        newData.ATR14 = newData.TR14 / 14 
        // +DI14
        newData.DI14High = newData.DMHigh14 / newData.TR14 * 100 
        // -DI14
        newData.DI14Low = newData.DMLow14 / newData.TR14 * 100
        // DIDiff 
        newData.DIDiff = Math.abs(newData.DI14High - newData.DI14Low)
        // DISum
        newData.DISum = newData.DI14High + newData.DI14Low
        // DX  
        newData.DX = newData.DIDiff / newData.DISum * 100

        // 超过28天可以开始计算ADX
        if(DATA_SOURCE.length >= (RANGE_DAY_COUNT * 2 - 1)) {
          // 如果是刚好满足条件，需要做累计计算
          if(DATA_SOURCE.length == (RANGE_DAY_COUNT * 2 - 1)) {
            const previousData = DATA_SOURCE.slice(DATA_SOURCE.length - RANGE_DAY_COUNT - 1)

            // adx 
            newData.ADX = (newData.DX + previousData.reduce((acc, cur) => {
              acc += cur.DX
              return acc 
            }, 0)) / RANGE_DAY_COUNT

          }
          // 超过条件只要简单使用昨日数据进行计算即可
          else {
            const { ADX } = yestoday

            // adx
            newData.ADX = (ADX * (RANGE_DAY_COUNT - 1) + newData.DX) / RANGE_DAY_COUNT

          }
        }

        // 超过14 * 3 天开始计算ADXR
        // 因为28天后才能计算ADX
        // ADXR计算需要14天前的ADX
        if(DATA_SOURCE.length >= RANGE_DAY_COUNT * 3) {
          newData.ADXR = (newData.ADX + newData[newData.length - RANGE_DAY_COUNT]) / 2
          newData.CSI = newData.ADXR * newData.ATR14 * ( 100 / 1 * (1 / 150 + newData.charge) ) * 100 
        }

      }

    }

    // ---具体的交易操作---
    // 计算出ADXR才算能开始真正的交易
    if(DATA_SOURCE.length >= RANGE_DAY_COUNT * 3) {

      // ADXR超过25表示有利可图
      // CSI越高越好
      // 关于CSI的大小标准还有待考证
      if(newData.ADXR > 25 && newData.CSI > 400) {

        // DI14 < -DI14 时多头
        // DI14 > -DI14 时空头
        // ADX < (DI14&-DI14) 时空头
        // DI14 == -DI14


        // 空头 ADX < (DI14&-DI14)
        if(newData.ADX < newData.DI14High && newData.ADX < newData.DI14Low) {
          if(TRADE_INFO.status === 1) {
            TRADE_INFO.status = 0
            TRADE_INFO.limit = newData.high 
          }
        }
        // 空头
        else if(newData.DI14High > newData.DI14Low) {
          // 初始化或者当日最低价 低于 交叉时的最低价
          // 改动为空头
          if(TRADE_INFO.status === -1 || newData.low < TRADE_INFO.limit) {
            // 赋值当前的买卖信息，为下次做准备
            TRADE_INFO.status = 1 
            TRADE_INFO.limit = newData.high
          }
        }
        // 多头
        else if(newData.DI14High < newData.DI14Low) {
          // 初始化或者当日最高价 高于 交叉时的最高价
          // 改动为多头
          if(TRADE_INFO.status === -1 || newData.high > TRADE_INFO.limit) {
            TRADE_INFO.status = 0 
            TRADE_INFO.limit = newData.low 
          }
        }

      }
    }

    // ---具体的交易操作---

    DATA_SOURCE.push(newData)

  }

```

> 存在问题  
  1. 上面`ADXR`超过25才是有利可图，但是如果在产品的`ADXR`超过25时买入，但是之后降低到了25以下，此时，入市的资金该如何处理。  
  2. 大趋势下，如持续上涨，是否需要对持续**DI交叉**做更多的资金买入。  
  3. 具体的交易操作还可以根据**ADX**来进行更细致的判断，更多细节有待接着研究（55页）。  
  4. 上述代码需要一个特殊的指标`CSI`，可能在第九章有讲到，待阅读😁 （经过阅读，九章中对于`CSI`的定义是越高越好，但是做的是一个相对比较，并没有明确说明高于某一个值表示有利可图，待考证）。    

### 期货品种选择指标CSI  

  为什么先写这一章，因为他跟前面第四章有关（但是也没有那么有关）。 
  > ps  
    因为本人并没有想去做期货等相关的交易，所以可能对于本章，作用不大，简单带过。  

  #### 公式  
  <img src="/images/技术交易系统新概念笔记/期货品种选择指标CSI-CSI公式.jpg" />  

  1. ADXR  
    第四章中提到的动向指标。  
  2. ATR14  
    14天的平均真实价格范围。  
    根据前面基本概念中提到的`TR`计算而来。  
  3. V  
    每运动1分（货币单位）、实际代表的价值（即以货币单位计量的ATR14的基本增幅）  
    笔者理解的意思应该就是市场每运动一个货币单位时，每份合约所发生的价格变动（那在股票中是不是就是**一手**的意思）。  
  4. M  
    保证金数量  
  5. C  
    手续费  

  #### 总结  
    根据上面的公式以及书中的介绍，`CSI`越高，说明交易越有利，并且可能风险也更小。  
    （本人因为可能交易的是股票，所以上面的保证金并不存在）。  

### 动量概念-趋势平衡点交易系统  

#### 几个概念  
##### MF  
  动量因子，描述价格变化的加速度，比如昨天比前天增加了1块，今天比昨天多增加1块的话，动量因子为0，因为加速度没有发生变化。  
  <img src="/images/技术交易系统新概念笔记/动量概念-趋势平衡点交易系统-动量因子.jpg" />  
  - 计算  
    当日收盘价 - 前天的收盘价  

##### TBP  
  趋势平衡点  

#### 交易过程  
  1. 当日MF > 昨日MF && 当日MF > 前天MF  
    **多头**  
  2. 当日MF < 昨日MF && 当日MF < 前天MF  
    **空头**  
  3. **目标价位**了结，不做**反向**交易   
  4. **停止点**结束交易，不做**反向**交易  
  5. 了结后再次进入遵循`1、2`规则  

## 结束  
