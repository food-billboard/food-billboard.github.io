---
title: 前端基础回顾-3-手写源码
date: 2023-02-15 14:21:00
tags: basic   
banner_img: /images/前端基础回顾/background.jpeg
index_img: /images/前端基础回顾/background.jpeg
categories: 
  - 面试
---

这是前端基础回顾的第三篇，记录一下一些手写源码的例子。  

## 开始

### 深拷贝  
```js
  function deepClone(object, map=new Map()) {
    if(typeof object !== 'object') {
      return object 
    }
    if(map.get(object)) return map.get(object)
    let result = {}
    if(Object.prototype.toString.call(object) === '[object Array]') {
      result = []
    }

    map.set(object, result)

    for(objectKey in object) {
      if(object.hasOwnProperty(objectKey)) {
        result[objectKey] = deepClone(object[objectKey])
      }
    }
    return result 
  }
```

### 0.1 + 0.2 === 0.3  
```js
function isNumberEqual(number1, number2) {
  return Math.abs(number1 - number2) < Math.EPSILON
}
```

### call、apply、bind  
```js
  // call 
  Function.prototype.myCall = function(context) {
    if(typeof this !== 'function') {
      throw new Error('is not a function')
    }
    const symbol = Symbol()
    const args = [...arguments].slice(1)
    context = context || window 
    context[symbol] = this  
    const result = context[symbol](...args)
    delete context[symbol] 
    return result 
  }

  // apply 
  Function.prototype.myApply = function(context) {
    if(typeof this !== 'function') {
      throw new Error('is not a function')
    }
    const symbol = Symbol()
    let args = [...arguments][1]
    args = Array.isArray(args) ? args : [] 
    context = context || window 
    context[symbol] = this 
    const result = context[symbol](...args)
    delete context[symbol] 
    return result 
  }

  // bind 
  Function.prototype.myBind = function(context) {
    if(typeof this !== 'function') {
      throw new Error('is not a function')
    }
    const args = [...arguments].slice(1)
    context = context || window 
    function fn() {
      const realArgs = [...args, ...arguments]
      return this.call(this instanceOf fn ? this : context, ...realArgs)
    }
    return fn 
  }

```

### new  
```js 
  function myNew(context) {
    const obj = Object.create(null)
    obj.__proto__ = context.prototype 
    const result = context.apply(obj, [...arguments].slice(1))
    return typeof result === 'object' ? result : obj  
  }
```

### instanceof 
```js
  function myInstanceof(target, origin) {
    let proto = target.__proto__
    const prototype = origin.prototype 
    while(proto) {
      if(prototype === proto) return true 
      proto = proto.__proto__
    }
    return false 
  }
```

### flag 
```js

Array.prototype.myFlat = function(deep) {
  const origin = this 
  function flat(array, deep) {
    let result = []
    for(let i = 0; i < array.length; i ++) {
      const item = array[i]
      if(Array.isArray(item) && (deep > 0)) {
        result.push(...flat(item, deep === Infinity ? deep : (deep - 1)))
      }else {
        result.push(item)
      }
    }
    return result 
  }
  return flat(origin, deep || 1)
}

```

### reduce 
```js

Array.prototype.myReduce = function(handler, initialValue) {
  let total = initialValue || 0 
  const origin = this 
  for(let i = 0; i < origin.length; i ++) {
    total = handler(total, origin[i], i, origin)
  }
  return total 
}

```

### 防抖和节流  
```js 
  // 节流
  function throttle(func, options={}) {
    const { wait=100 } = options 
    let done = true 
    return function(...args) {
      if(!done) return 
      done = false 
      setTimeout(() => {
        func(...args)
        done = false 
      }, wait)
    }
  }

  // 防抖  
  function debounce(func, options={}) {
    const { wait=100 } = options 
    let timeout 
    let done = true 
    return function(...args) {
      if(!done) clearTimeout(timeout)
      done = false 
      timeout = setTimeout(() => {
        func(...args)
        done = true 
      }, wait)
    }
  }
```

### Promise  
```js

const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class MyPromise {
  constructor(executor) {
    executor(this.resolve, this.reject)
  }

  status = PENDING 
  value = undefined 
  reason = undefined 

  resolve = (value) => {
    if(this.status === PENDING) {
      this.status = FULFILLED
      this.value = value 
    }
  }

  reject = (reason) => {
    if(this.status === PENDING) {
      this.status = REJECTED
      this.reason = reason 
    }
  }

  then = (onFulfilled, onReject) => {
    if(this.status === FULFILLED) {
      onFulfilled(this.value)
    }else if(this.status === REJECTED) {
      onReject(this.reason)
    }
  }

}

const promise = new MyPromise((resolve, reject) => {
  if(Math.random() > 0.5) {
    resolve('resolve')
  }else {
    reject('reject')
  }
})

promise
.then(value => {
	console.log(value)
}, reason => {
	console.log(reason)
})

```

### 数字累加
```js
function add(start, end) {
  return (start + end) * (end - start + 1) / 2
}
```

### 随机范围数字
```js
  function randomNumber(start, end, startContain=true, endContain=true) {
    const number = Math.random() * (end - start + 1) + start 
  }
```
### 前几个斐波那契
```js
  function fibonacci(limit) {
    function cal(number) {
      return number < 2 ? number : cal(number - 1) + cal(number - 2)
    }
    return new Array(limit).fill(0).map((_, index) => {
      return cal(index + 1)
    })
  }
```

### 随机排序  
```js
  function randomSort(arr) {
    const length = arr.length 

    for(let index = 0; index < length; index ++) {
      const ind = Math.floor(Math.random() * (length - index)) - index
      [arr[index], [arr[ind]]] = [arr[ind], arr[index]] 
    }
  
  }
```

### 通用事件模型  
```js
  class EventUtil {

    addEventListener(element, event, handler) {
      if(element.addEventListener) {
        element.addEventListener(event, handler)
      }else if(element.attachEvent) {
        element.attachEvent(`on${event}`, handler)
      }else {
        element[`on${event}`] = handler 
      }
    }

    removeEventListener(element, event, handler) {
      if(element.removeEventListener) {
        element.removeEventListener(event, handler)
      }else if(element.detachEvent) {
        element.detachEvent(`on${event}`, handler)
      }else {
        element[`on${event}`] = null  
      }
    }

    getEventTarget(event) {
      return event.target || event.srcElement 
    }

    getEvent(event) {
      return event || window.event 
    }

    stopPropagation(event) {
      if(event.stopPropagation) {
        event.stopPropagation()
      }else {
        event.cancelBubble = true 
      }
    }

    preventDefault(event) {
      if(event.preventDefault) {
        event.preventDefault()
      }else {
        event.returnValue = false  
      }
    }

  }
```

### ajax  
```js
  const xhr = new XMLHttpRequest()

  xhr.open('GET', '/request', true)

  xhr.onreadystatechange = function() {
    if(this.readyState == 4) return 

    if(this.status == 200) {
      // TODO 
    }
  }

  xhr.onerror = function() {

  }

  xhr.send()

```

## 结束  

  结束🔚。  

  > 参考资料
  [从URL输入到页面展现到底发生什么？](https://juejin.cn/post/6844903784229896199)  
  
