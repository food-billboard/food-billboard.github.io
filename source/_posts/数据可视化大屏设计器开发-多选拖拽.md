---
title: 数据可视化大屏设计器开发-多选拖拽  
date: 2023-01-10 14:05:00
tags: lowcode react chart 
banner_img: /images/数据可视化大屏设计器开发/background.jpg
index_img: /images/数据可视化大屏设计器开发/background.jpg
categories: 
  前端  
---

# 数据可视化大屏设计器开发-多选拖拽  

## 开头  

本文是数据可视化开始的开发细节第五章。关于画布中的元素的各种鼠标拖拽操作。    

> 简单声明  
本人只是一个菜鸡，以下方法仅个人思路，如有错误，轻喷🙏🏻 。  

> 开头说明  
下面所说的**元素**表示的是**组或者组件**的简称。   

## 开始  

大屏设计当中，不乏需要调整图表组件的**位置**和**尺寸**。  
相较于网页低代码，图表大屏低代码可能需要更复杂的操作，比如嵌套成组、多选、单元素拖拽缩放、多元素拖拽缩放。  
并且需要针对鼠标的动作做相应的区分，当中包含了相当的细节，这里就一一做相应的讲解。  

### 涉及的依赖  

- react-rnd  
[react-rnd](https://github.com/bokuweb/react-rnd)是一个包含了拖拽和缩放两个功能的`react`组件，并且有非常丰富的配置项。  
内部是依赖了拖拽([react-draggable](https://github.com/react-grid-layout/react-draggable))和缩放（[re-resizable](https://github.com/bokuweb/re-resizable)）两个模块。  
奈何它并没有内置多元素的响应操作，本文就是针对它来实现对应的操作。  

- react-selecto  
[react-selecto](https://github.com/daybrush/selecto/tree/master/packages/react-selecto)是一个简单的简单易用的多选元素组件。  

- eventemitter3  
[eventemitter3](https://github.com/primus/eventemitter3)是一个自定义事件模块，能够在任何地方触发和响应自定义的事件，非常的方便。  

### 相关操作  

#### 多选  
画布当中可以通过鼠标点击拖拽形成选区，选区内的元素即是被选中的状态。  

这里即可以使用`react-selecto`来实现此功能。  
```typescript 
  import ReactSelecto from 'react-selecto';

  const Selecto = (props: {
    setSelect: (value: string[]) => void;
  }) => {
    const { setSelect } = props;

    const currentSelect = useRef<string[]>([]);

    const handleSelectEnd = useCallback(() => {
      setSelect(currentSelect.current);
    }, [setSelect]);

    const handleSelect = useCallback((e: any) => {
      const { added, removed } = e;

      const toAddList = added.reduce((acc: any, element: any) => {
        const select = element.dataset.id;
        if (!isComponentDisabled(select)) {
          acc.push(select);
        }
        return acc;
      }, []);
      const toRemoveList = removed.map((element: any) => element.dataset.id);

      const newSelect = [
        ...currentSelect.current.filter((item) => !toRemoveList.includes(item)),
        ...toAddList,
      ];
      currentSelect.current = newSelect;
    }, []);

    const handleDragStart = useCallback(
      (e: any) => {
        try {
          // 背景 大画布等
          const id = e.inputEvent.target.id;
          // 组件id
          const componentId = e.inputEvent.target.dataset?.id;
          // 组件边框 或其他一些
          const componentBorder =
            e.inputEvent.target.className.includes(SELECTO_CLASSNAME);
          // 辅助线
          const guideLine =
            e.inputEvent.target.className.includes('ruler-guide-line');
          // 标尺
          const ruler = e.inputEvent.target.tagName.toLowerCase();

          const select = getGlobalSelect();

          if (
            VALID_SELECT_CONTAINER.includes(id) ||
            (!componentBorder &&
              !guideLine &&
              ruler !== 'canvas' &&
              !isComponentSelect(componentId, select))
          ) {
            setSelect?.([]);
          } else {
            e.stop();
          }
        } catch (err) {
          e.stop();
        }
      },
      [setSelect],
    );

    return (
      <ReactSelecto
        // 会被选中元素的父容器 只有这个容器里的元素才会被选中  
        dragContainer={'#container'}
        // 被选择的元素的query 
        selectableTargets={['.react-select-to']}
        hitRate={10}
        // 当已经存在选中项时，按住指定按键可进行继续选择  
        toggleContinueSelect={'shift'}
        // 可以通过点击选择元素
        selectByClick
        // 
        selectFromInside
        ratio={0}
        onDragStart={handleDragStart}
        onSelectEnd={handleSelectEnd}
        onSelect={handleSelect}
      ></ReactSelecto>
    );
  };
```

这里有几个需要注意的地方。  
1. 操作互斥  
画布当中的多选和拖拽都是通过鼠标左键来完成的，所以当一个元素是被选中的时候，鼠标想从元素上开始拖拽选择组件是不被允许的，此时应该是拖拽元素，而不是多选元素。  
<img src="/images/数据可视化大屏设计器开发/多选操作互斥.jpg" />
而元素如果没有被**选中**时，上面的操作则变成了多选。  
<img src="/images/数据可视化大屏设计器开发/多选操作互斥.jpg" />
2. 内部选中  
画布当中有**组**的概念，它是一个组与组件无限嵌套的结构，并且可以单独选中组内的元素。   
当选中的是**组内**的元素时，即说明最外层的组是被**选中**的状态，同样需要考虑上面所说的**互斥**问题。   
<img src="/images/数据可视化大屏设计器开发/多选操作互斥.jpg" />

#### 单元素拖拽缩放  
单元素操作相对简单，只需要简单使用`react-rnd`提供的功能即可完成。  
```typescript 

```

#### 多元素拖拽缩放  
这里就是本文的重点了，结合前面介绍的几个依赖，实现一个简单的多选拖拽缩放的功能。  

##### 具体思路  
多个元素拖拽，说到底其实鼠标拖拽的还是一个元素，就是**鼠标拖动**的那一个元素。  
而**其余**被选中的元素，仅仅需要根据被拖动的元素的尺寸位置变动来做相应的**加减处理**即可。  
##### 相关问题  
- 信息计算   
联动元素的位置尺寸信息该如何计算。  
- 组件间通信  
因为每一个图表组件并非是单纯的同级关系，如果是通过层层`props`传递，免不了会有多余的刷新，造成**性能**问题。  
而通过全局的`dva`状态同样在更新的时候会让组件刷新。  
- 数据刷新  
图表数据是来自于`dva`全局的数据，现在频繁自刷新相当于是一直更新全局的数据，同样会造成**性能**问题。  
- 其他  
一些细节问题  

#### 解决方法
- 信息计算  
关于位置的计算相对简单，只需要单纯的将操作的元素的位置和尺寸差值传递给联动组件即可。  
- 组件间通信  
根据上面问题的解析，可以使用`eventemitter3`来完成任意位置、层级的数据通信，并且它和`react`渲染无任何关系。  
```typescript 
import { useCallback, useEffect } from 'react'
import EventEmitter from 'eventemitter3'

const eventemitter = new EventEmitter()

const SonA = () => {

  console.log('刷新')

  useEffect(() => {
    const listener = (value) => {
      console.log(value)
    }
    eventemitter.addListener('change', listener)
    return () => {
      eventemitter.removeListener('change', listener)
    }
  }, [])

  return (
    <span>son A</span>
  )

}

const SonB = () => {

  const handleClick = useCallback(() => {
    eventemitter.emit('change', 'son B')
  }, [])

  return (
    <span>
      <button onClick={handleClick}>son B</button>
    </span>
  )

}

const Parent = () => {

  return (
    <div>
      <SonA />
      <br />
      <SonB />
    </div>
  )

}

```
运行上面的例子可以发现，点击`SonB`组件的按钮，可以让`SonA`接收到来自其的数据，并且并没有触发`SonA`的刷新。  
需要**接收数据**的组件只需要监听(`addListener`)指定的事件即可，比如上面的`change`事件。  
而需要**发送数据**的组件则直接发布(`emit`)事件即可。  
这样就避免了一些不必要的刷新。   
<img src="/images/数据可视化大屏设计器开发/eventemitter3.gif" />
- 数据刷新  
频繁刷新全局数据，会导致所有依赖其数据的组件都会刷新，所以考虑为需要刷新数据的组件在内部单独维护一份状态。  
当**开始操作**时，记录下状态，标识开始使用**内部状态**表示图表的信息，**结束操作**时处理下内部数据状态，将数据更新到全局中去。  

```typescript 
  import { useMemo, useEffect, useState, useRef } from 'react'
  import EventEmitter from 'eventemitter3'

  const eventemitter = new EventEmitter()

  const Component = (props: {
    position: {left: number, top: number}
  }) => {

    const [ position, setPosition ] = useState({
      left: 0,
      top: 0
    })

    const isDrag = useRef(false)

    const dragStart = () => {
      isDrag.current = true 
      setPosition(props.position)
    }

    const drag = (position) => {
      setPosition(position)
    }

    const dragEnd = () => {
      isDrag.current = false 
      // TODO 
      // 更新数据到全局
    }

    useEffect(() => {
      eventemitter.addListener('dragStart', dragStart)
      eventemitter.addListener('drag', drag)
      eventemitter.addListener('dragEnd', dragEnd)
      return () => {
        eventemitter.removeListener('dragStart', dragStart)
        eventemitter.removeListener('drag', drag)
        eventemitter.removeListener('dragEnd', dragEnd)
      }
    }, [])

    return (
      <span
        style={{
          left: (isDrag.current ? position : props.position).left,
          top: (isDrag.current ? position : props.position).top
        }}
      >图表组件</span>
    )

  }


```

> 上面的数据更新还可以更加优化，对于**短时间**的**多次**更新操作，可以控制一下更新频率，将多次更新合并为一次。  

- 其他  
  - 控制刷新  
  这里的控制刷新指的是上述的内部刷新，不需要每次都响应`react-rnd`发出的相关事件，可以做对应的节流(`throttle`)操作，减少事件触发频率。  
  - 通信冲突问题  
  因为**所有的组件**都需要监听拖拽的事件，包括当前被拖拽的组件，所以在传递信息时，需要把自身的`id`类似值传递，防止冲突。  
  - 组件的缩放属性  
  这里是关于前文说到的**成组**的逻辑相关，因为组存在`scaleX`和`scaleY`两个属性，所以在**调整大小**的时候，也要兼顾此属性（本文先暂时不考虑这个问题）。  
  - 单元素选中情况  
  自定义事件的监听是**无差别**的，当只选中了一个元素进行拖拽缩放操作时，无须触发相应的事件。  
#### 最后的DEMO  
```typescript 

```
## 总结  

通过上面的思路，即可完成一个简单的多元素拖拽缩放的功能，其核心其实就是`eventemitter3`的自定义事件功能，它的用途在平常的业务中非常广泛。  
比如我们完全可以在以上例子的基础上，加上元素**吸附**的功能。    

## 总结  
本文主要讲解了大屏当中的**多选拖拽**相关的操作。  
其实不难发现， 

## 结束  

  结束🔚。  

  顺便在下面附上相关的链接。  
> [试用地址](http://47.97.27.23/api/backend/screen/index.html)  
[试用账号](https://github.com/food-billboard/create-chart/issues/2)  
[操作文档](http://47.97.27.23/api/backend/create-chart-docs/index.html)  
[代码地址](https://github.com/food-billboard/create-chart)       